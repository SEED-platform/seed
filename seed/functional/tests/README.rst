Functional Testing with Selenium
================================

The tests in seed.functional.tests.test_browser use Selenium to
test things actually work in a browser. There are a number of things
you need to know before adding tests.

..warning::
    Ignore this at your peril!

In order to test against multiple browsers without having to duplicate Test Classes the Test Cases, the classes they subclass from, and all the tests themselves  are all generated on the fly.

The tests are written in such a way that, hopefully, adding tests, will be familiar, and little different from normal. If all you want to do is add a test, providing you bear in mind the caveats below, you shouldn't need to concern your self with how things actually work behind the scenes. Follow the instructions and you can write one test method and it will automatically run against multiple browsers.

Adding a test
-------------
test_browser.py contains two basic test classes:

    LoggedOutTests
        this contains test methods that run when a user is logged out


    LoggedInTests
        this contains test methods that run when a user is logged in

These should be sufficient for most cases and you can just add your test as
normal.

.. WARNING:: These are not defined in the top level scope

Rather they are defined **within** the equivalent generator. e.g. loggedout_tests_generator. This is the key to the behind the scenes magic, the generator invokes the class multiple times,  each time sub-classing it from a different base class. These are identical but for the fact that they use a different browser to power the tests.

As long as you respect this, and indent your methods properly, you can write your tests as normal. You should also read the section, Running Tests, however, as the tests are not run in the normal way, so the error message generated by a failing test may surprise you.

Adding a browser specific test.
-------------------------------
... WARNING:: Test detection, internally, is as smart as say Nose, tests must begin with ```test_``` to be recognized.
Define your test as normal but put anything browser specific behind a guard condition. To do this you can test against the browser name::

    if self.browser_type.name == 'Firefox':

The Browser Definition that defines this name is contained in browser_definition.py.

You can also add tests that will only be invoked by Travis using::

    if os.getenv('TRAVIS') == 'true':

When tests are run locally(i.e. not on Travis) only cross platform browsers will be used. If you need to write a browser specfic test against anything else, and you wish to run the test locally, you can override this by setting the environment 'SEED_TEST_BROWSER' to one of IE, SAFARI, EDGE. This will cause that browser to be used as well. You will need to ensure you have the relevant driver installed.

Running Tests.
--------------
Tests can be run as normal, but a failing test may produce different output from what you are expecting. In particular the FAIL: statement will list the name of the generator, not the test method. So you will see

However the place the test failed can still be derived from the Traceback
e.g.::

    Traceback (most recent call last):
        [snip]...
        File "/home/paulmunday/projects/seed/seed/functional/tests/test_browser.py",    line 341, in test_pass


Adding Test Cases to test_browsers.py
-------------------------------------
The included classes should be sufficient but it is easy enough to add more. Just make sure to wrap you class definition in a generator. You can base this off an existing generator like so::

    def my_test_generator():
        for browser in BROWSERS:
            class MyTestClass(LOGGED_IN_CLASSES[browser.name]):
                def my_test(self):
                    pass
            Test = LoggedOutTests()
              for test in get_tsts(Test):
                  yield test


Lets break that down a little:

``` for browser in BROWSERS:``` In combination with the next line this will create a copy of your test for each browser. BROWSERS is imported from base.py and is a list of BrowserDefinitions

```class MyTestClass(LOGGED_IN_CLASSES[browser.name]):```
Rather than sub-classing directly this supplies a different base case each time we go around the loop. In this case the base classes are taken from LOGGED_IN_CLASSES. This is imported from base.py: its a list of Base Classes generated there that each use a different browser to power the same base Test Class. (LOGGED_OUT_CLASSES is also defined and it also possible to define other base classes  there). This gives us the ability to test against multiple browsers easily. *You must* inherit from a class defined there.

``` Test = LoggedOutTests()``` Here we instantiate a copy of out derived test class. Since we invoke it directly, not via the test runner, the setUp methods won't be called, however get_tsts takes care of this.

```for test in get_tsts(Test):`` get_tsts takes care of running the setUpClass method for us, then it examines the test class we passed looking for methods it thinks are tests (i.e. their name begins with ```test_```). When it finds one it wraps it in a function that the test runner can call (making sure to invoke the setUp and tearDown methods) and will be safe for the generator to yield. (you can't return a Test Class from the generator, as unittest expects a function).

... Caution :: see setUp and tearDown below if you intend to override these.


setUp and tearDown
------------------

If you want to override these you need to be aware there are not invoked by the test runner. Instead the function yielded by the generator invokes them manually . You must take care to reverse anything you did in the setup (especially anything that calls a Model) or stuff will break in unpredictable ways. You should be doing this regardless anyway. Also be sure to call super as this takes care of opening and closing the browser.

base.py
=======
This takes care of defining the base classes for use in tests.

Adding a new base class.
------------------------
Add your class definition as normal, sub-classing ```FunctionalLiveServerBaseTestCase``` or one of the classes from derived from this.

Next add a factory function::

    def myTestCaseFactory(browser):
        classname = get_classname('myTestCase', browser.name)
        return type(
            classname, (myTestCase, ),
            {'browser_type': browser}
        )

Then at the end of the file add a blank container dictionary and a call to
your factory function in for loop::

    MY_TEST_CLASSES = {}
    for browser in BROWSERS:
        bname = browser.name
        MY_TEST_CLASSES[bname] = myTestCaseFactory(browser)

This will fill your container dictionary with Browser specific versions of your base class like this::

    {
        'Firefox': MyTestCaseFirefox,
        ...
    }

 The container dictionary can then be imported in test_browser for use.

browser_definitions.py
======================
This defines browser objects and capabilities in order to set the right web driver on tests. They are used by the class factories in base.py and test generators
in test_browser.py to generate browser specific versions of the test classes.
Browser definitions for Firefox, Chrome, Internet Explorer,

Adding a BrowserDefinition
--------------------------

A Browser definition is a named tuple that defines a browser for use in Test classes. e.g.::

    myBrowser = BrowserDefinition(
        name = 'MyBrowserName',
        Capabilites = MyBrowserCapabilities,
        driver = MyBrowser.webdriver
    )

    or

    myBrowser = BrowserDefinition(
        'MyBrowserName', MyBrowserCapabilities, MyBrowser.webdriver
    )

Definitions:
    * name is a string, e.g. browser name (and version).
    * Capabilities is a dictionary that will be passed to the remote
      webdriver via Travis (which passes it to Sauce Labs)
      Describing it further is out of scope for this document.
      see: https://wiki.saucelabs.com/display/DOCS/Test+Configuration+and+Annotation
    * webdriver will used to power the tests if they are run locally.
      Normally this can just be MyBrowser.webdriver, but you can
      define any function and pass it in here. Note for both it *must* be
      func not func() or webdriver not webdriver()

A browser capabilities factory is provided for your convinience in base.py.
This should ensure a valid browser capacity definition.

Depending on whether the tests are running locally or on Travis Capabilities or driver will be used.

Make sure to add your browser definition to BROWSERS (or equivalent) (and your capacity to BROWSER_CAPACITIES).


The Gory Details
================

There's a lot of indirection and dynamic definition going on underneath the hood (compounded by the fact that theres a lot of deep magic going on with unit tests in the first place). However I tried to write in such a way that it uses common idioms for things that will be changed frequently so mostly this can be ignored. Explanations for what is going on can be found below if you want, or need, to know.

The rationale for all this is easy testing across multiple browsers. As long as we wrap them in the right way we need only to write our base and test classes once and we will get a set of tests for each browser definition with out having to worry about the definitions, if a new definition is added it will automatically get picked up by all tests.

browser_definitions.py
----------------------
This file contains a series of browser definitions to make it easy to test against multiple browsers. This are contained in the BROWSERS list. It also contains definitions for that test for a valid browser capability if ```browser_cap_factory``` is used to generate one.

base.py
-------
This contains the base class definition ```FunctionalLiveServerBaseTestCase``` as well as other classes derived from it. The thing to note about this is that the setUp method detects the environment the tests are running in in the setUp method and uses this to add the correct browser instance to the class instance.

At the end of the file this list is looped over and the browser definition passed to a factory function. This takes the base class and returns a browser specific version of it so TestCaseFactory(browser) returns TestCaseFactoryBrowser which is added to a dictionary that can be imported elsewhere.

test_browsers.py
----------------
This contains the actual tests themselves. It imports BROWSERS and the browser class dictionaries e.g. LOGGED_OUT_CLASSES from base.by.

The Test Classes defined here live inside a generator.

Each generator loops over BROWSERS and subclasses the appropriate base class from the browser class dictionary. It would be nice if we could yield this test class instance directly and pass it to the test runner. Unfortunately unittest expects a function from a generator. Actually things are a little more complicated than this. If you yield an object that's not a function (i.e. everything else) it looks for the presence of a runTest method on it. If it find one it decides its a test and will call the object directly (not the runTest method) so yielding a class is like calling Class(), i.e. it instantiates the class but doesn't call the test_methods.

To get around this the generator instantiates a copy of that class and passes it to get_tsts(). This takes care of calling setUpClass, which would not otherwise be run, then inspects the object for test method. When it finds one it wraps a call to that method in a function that takes care of invoking setUp and tearDown before, and after its run. Since it is now a function this can  be safely yielded by the generator to be invoked by the test runner.
